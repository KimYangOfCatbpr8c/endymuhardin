module wijmo.olap {
    'use strict';

    /**
     * Represents a property of the items in the wijmo.olap data source.
     */
    export class PivotField {
        private _ng: PivotEngine;
        private _header: string;
        private _aggregate: Aggregate;
        private _showAs: ShowAs;
        private _weightField: PivotField;
        private _format: string;
        private _width: number;
        private _wordWrap: boolean;
        private _dataType: DataType;
        private _filter: PivotFilter;
        private _descending: boolean;
        private _isContentHtml: boolean;
        private _parent: PivotField;
        /*private*/ _binding: Binding;
        /*private*/ _autoGenerated: boolean;

        // serializable properties
        static _props = [
            'dataType',
            'format',
            'width',
            'wordWrap',
            'aggregate',
            'showAs',
            'descending',
            'isContentHtml'
        ];

        /**
         * Initializes a new instance of the @see:PivotField class.
         *
         * @param engine @see:PivotEngine that owns this field.
         * @param binding Property that this field is bound to.
         * @param header Header shown to identify this field (defaults to the binding).
         * @param options JavaScript object containing initialization data for the field.
         */
        constructor(engine: PivotEngine, binding: string, header?: string, options?: any) {
            this._ng = engine;
            this._binding = new Binding(binding);
            this._header = header ? header : toHeaderCase(binding);
            this._aggregate = Aggregate.Sum;
            this._showAs = ShowAs.NoCalculation;
            this._isContentHtml = false;
            this._format = '';
            this._filter = new PivotFilter(this);
            if (options) {
                copy(this, options);
            }
        }

        // ** object model

        /**
         * Gets or sets the name of the property the field is bound to.
         */
        get binding(): string {
            return this._binding ? this._binding.path : null;
        }
        set binding(value: string) {
            if (value != this.binding) {
                var oldValue = this.binding,
                    path = asString(value);
                this._binding = path ? new Binding(path) : null;
                if (!this._dataType && this._ng && this._binding) {
                    var cv = this._ng.collectionView;
                    if (cv && cv.sourceCollection && cv.sourceCollection.length) {
                        var item = cv.sourceCollection[0];
                        this._dataType = getType(this._binding.getValue(item));
                    }
                }
                var e = new PropertyChangedEventArgs('binding', oldValue, value);
                this.onPropertyChanged(e);
            }
        }
        /**
         * Gets or sets a string used to represent this field in the user interface.
         */
        get header(): string {
            return this._header;
        }
        set header(value: string) {
            value = asString(value, false);
            var fld = this._ng.fields.getField(value);
            if (!value || (fld && fld != this)) {
                assert(false, 'field headers must be unique and non-empty.');
            } else {
                this._setProp('_header', asString(value));
            }
        }
        /**
         * Gets a reference to the @see:PivotFilter used to filter values for this field.
         */
        get filter(): PivotFilter {
            return this._filter;
        }
        /**
         * Gets or sets how the field should be summarized.
         */
        get aggregate(): Aggregate {
            return this._aggregate;
        }
        set aggregate(value: Aggregate) {
            this._setProp('_aggregate', asEnum(value, Aggregate));
        }
        /**
         * Gets or sets how the field results should be formatted.
         */
        get showAs(): ShowAs {
            return this._showAs;
        }
        set showAs(value: ShowAs) {
            this._setProp('_showAs', asEnum(value, ShowAs));
        }
        /**
         * Gets or sets the @see:PivotField used as a weight for calculating
         * aggregates on this field.
         *
         * If this property is set to null, all values are assumed to have weight one.
         *
         * This property allows you to calculate weighted averages and totals. 
         * For example, if the data contains a 'Quantity' field and a 'Price' field,
         * you could use the 'Price' field as a value field and the 'Quantity' field as
         * a weight. The output would contain a weighted average of the data.
         */
        get weightField(): PivotField {
            return this._weightField;
        }
        set weightField(value: PivotField) {
            this._setProp('_weightField', asType(value, PivotField, true));
        }
        /**
         * Gets or sets the data type of the field.
         */
        get dataType(): DataType {
            return this._dataType;
        }
        set dataType(value: DataType) {
            this._setProp('_dataType', asEnum(value, DataType));
        }
        /**
         * Gets or sets the format to use when displaying field values.
         */
        get format(): string {
            return this._format;
        }
        set format(value: string) {
            this._setProp('_format', asString(value));
        }
        /**
         * Gets or sets the preferred width to be used for showing this field in the 
         * user interface.
         */
        get width(): number {
            return this._width;
        }
        set width(value: number) {
            this._setProp('_width', asNumber(value, true, true));
        }
        /**
         * Gets or sets a value that indicates whether the content of this field should
         * be allowed to wrap within cells.
         */
        get wordWrap(): boolean {
            return this._wordWrap;
        }
        set wordWrap(value: boolean) {
            this._setProp('_wordWrap', asBoolean(value));
        }
        /**
         * Gets or sets a value that determines whether keys should be sorted 
         * in descending order for this field.
         */
        get descending(): boolean {
            return this._descending ? true : false;
        }
        set descending(value: boolean) {
            this._setProp('_descending', asBoolean(value));
        }
        /**
         * Gets or sets a value indicating whether items in this field 
         * contain HTML content rather than plain text.
         */
        get isContentHtml(): boolean {
            return this._isContentHtml;
        }
        set isContentHtml(value: boolean) {
            this._setProp('_isContentHtml', asBoolean(value));
        }
        /**
         * Gets a reference to the @see:PivotEngine that owns this @see:PivotField.
         */
        get engine(): PivotEngine {
            return this._ng;
        }
        /**
         * Gets the @see:ICollectionView bound to this field.
         */
        get collectionView(): collections.ICollectionView {
            return this.engine ? this.engine.collectionView : null;
        }
        /**
         * Gets or sets a value that determines whether this field is
         * currently being used in the view.
         *
         * Setting this property to true causes the field to be added to the
         * view's @see:PivotEngine.rowFields or @see:PivotEngine.valueFields, 
         * depending on the field's data type.
         */
        get isActive(): boolean {
            if (this._ng) {
                var lists = this._ng._viewLists;
                for (var i = 0; i < lists.length; i++) {
                    var list = lists[i];
                    for (var j = 0; j < list.length; j++) {
                        if (list[j].binding == this.binding) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }
        set isActive(value: boolean) {
            if (this._ng) {
                var isActive = this.isActive;
                value = asBoolean(value);
                if (value != isActive) {
                    if (value) { // add to view

                        // add numbers to values, others to row fields
                        if (this.dataType == DataType.Number) {
                            this._ng.valueFields.push(this);
                        } else {
                            this._ng.rowFields.push(this);
                        }
                    } else { // remove from view

                        // remove field and copies from all view lists (by binding)
                        var lists = this._ng._viewLists;
                        for (var i = 0; i < lists.length; i++) {
                            var list = lists[i];
                            for (var f = 0; f < list.length; f++) {
                                var fld = <PivotField>list[f];
                                if (fld == this || fld.parentField == this) {
                                    list.removeAt(f);
                                    f--;
                                }
                            }
                        }

                        // remove any copies from main list
                        var list = this._ng.fields;
                        for (var f = list.length - 1; f >= 0; f--) {
                            var fld = <PivotField>list[f];
                            if (fld.parentField == this) {
                                list.removeAt(f);
                                f--;
                            }
                        }
                    }
                }
            }
        }
        /**
         * Gets this field's parent field.
         *
         * When you drag the same field into the Values list multiple
         * times, copies of the field are created so you can use the
         * same binding with different parameters. The copies keep a
         * reference to their parent fields.
         */
        get parentField(): PivotField {
            return this._parent;
        }

        /**
         * Occurs when the value of a property in this @see:Range changes.
         */
        propertyChanged = new Event();
        /**
         * Raises the @see:propertyChanged event.
         *
         * @param e @see:PropertyChangedEventArgs that contains the property
         * name, old, and new values.
         */
        onPropertyChanged(e: PropertyChangedEventArgs) {
            this.propertyChanged.raise(this, e);
            this._ng._fieldPropertyChanged(this, e);
        }

        // ** implementation

        // creates a clone with the same binding/properties and a unique header
        _clone(): PivotField {

            // create clone
            var clone = new PivotField(this._ng, this.binding);
            this._ng._copyProps(clone, this, PivotField._props);
            clone._autoGenerated = true;
            clone._parent = this;

            // give it a unique header
            var hdr = this.header.replace(/\d+$/, '');
            for (var i = 2; ; i++) {
                var hdrn = hdr + i.toString();
                if (this._ng.fields.getField(hdrn) == null) {
                    clone._header = hdrn;
                    break;
                }
            }

            // done
            return clone;
        }

        // sets property value and notifies about the change
        _setProp(name: string, value: any, member?: string) {
            var oldValue = this[name];
            if (value != oldValue) {
                this[name] = value;
                var e = new PropertyChangedEventArgs(name.substr(1), oldValue, value);
                this.onPropertyChanged(e);
            }
        }

        // get field name (used for display)
        _getName(): string {
            return this.header || this.binding;
        }

        // get field value
        _getValue(item: any, formatted: boolean): any {
            var value = this._binding._key
                ? item[this._binding._key] // optimization
                : this._binding.getValue(item);
            return !formatted || typeof (value) == 'string' // optimization
                ? value
                : Globalize.format(value, this._format);
        }

        // get field weight
        _getWeight(item: any): number {
            var value = this._weightField ? this._weightField._getValue(item, false) : null;
            return isNumber(value) ? value : null;
        }
    }
}